Anyone can build browsers, we have to follow a standard(given by ECMA international) that the browser-building companies have to follow. Companies like Google and Firefox wrote their engines to convert JS code to binary that can then be understood by the machine.
Native programs- That we can run on local machines. Earlier JS could only be used as web programs, so Node.js written by Google was pulled out and converted to a backend framework. Node.js is not a language or framework, it is just a JS runtime used to run JS in the backend in a local machine outside the Chrome browser.
JS is single-threaded language, which means it is kind of independent of how powerful our machine is, as it will utilize only one thread. 
JS is Asynchronous. Reading from a file, waiting for input from the key, writing to a database, or sending an HTTP request to a backend are all asynchronous tasks, as they can block the code if it is running synchronously. While asynchronous task is running we can do other tasks. (analogy- tell your friend to tell you that 1 hour has passed and now I have to drink water when I am busy studying. So now I don't have to look at the clock and can focus only on studying.) 
JS is loosely typed, the argument of a function need not be defined with its type. 
Interpreted language, goes line by line. While other languages like C++ will first do Compile checks, in its compilation time, it will give errors if the code has even a single error. (in JS the thread never goes inside a function until it is called, it just registers the function name.)
APIs- exposed by the runtime environment, for example, fs, fetch, setTimeout, and setInterval are APIs.
SetTimeout, setInterval takes a callback, and it is an asynchronous function.
If you know about async JS, callback, Promises, and arrow functions you can sprint much faster.
JS is asynchronous but it does not mean that it can do 2 tasks at the same time, if the thread is doing a time-consuming task and an asynchronous callback function is called during that  time, the async function will not work as the thread is busy executing the long task at the moment.
Promises are not needed as such in js, you can do the same thing without them, but js peeps want code to be clean, and using promises you can write cleaner code.
Call stack, web APIs, event loop, callback queue. Web Apis is the friend that does the async task in the background. Once that is done, it puts the callback function in the callback queue, the function then waits there until the call stack is empty and the event loop pulls the function from the callback queue and puts it into the call stack for executing it. http://latentflip.com/loupe Check this website to see how the simulation is done
Async chaining is done if you want one task to happen before another async task, because the first task is more important, eg, on chatgpt website the name appears before the upgrade plan and our history. Callback hell is this chaining of one async call after another, the code looks ugly due to this if we do more than 3 async calls one inside another.
Promise returns an object, .then() is a function that is used to call the function we want to execute once the promise is returned(the callback function). The promise function takes resolve as an argument, when resolve is called, the control reaches then, resolve is the first argument of promise function, can be called anything.
Backend- HTTP, Authentication, Database, Middlewares. Machines communicate using HTTP protocol with each other. Eg, I use servers of chatgpt to get answers to my questions as chatgpt servers run a very heavy ML algorithm, on my light machine which cannot use these algorithms on my local machine or phone. Eg, if you open Instagram, the feed, people's dp, etc comes from the servers/backend as they are not on my browser.
You need to know where to send the server, there are many servers- servers of Google, facebook, openai, etc. We need to know their backend URL, eg if it is chatgpt, we use HTTP://chat-openai.com. The next part is route which tells what algorithm we want to run example HTTP://chat-openai.com/conversation/ conversation is the route.
npm init -y initialize package.json file. Express is a library in nodejs that lets us create HTTP server. When you install new libraries, it is shown in the dependencies in package.json file. run node index.js to run the HTTP server.
A long running process is a process that runs infinitely, like setInterval, or a server. The significance of route is that each route lets us do something different. In fs.readfile, the callback function takes two arguments, err and data, data contains the content of the file. FS is also a library like express is a library, both of nodejs.
if we want to get input from user, we can do that using- query param, header, body. after the route add ? and then add the params. HTTP request has URL, route, and method. There are many methods, but the important one's are get, put, post and delete. Default is get request. Creating an account on instagram is a post request, updating data use put request, deletin use delete request. It doesn't have to be, it is a standard that is followed, we can do all things with get request, not recommended.
app.get('/:username') this become wildcard, any route will now be able to do get request.it can be extracted as req.params.username. It is hard to send post request from the browser so initially use postman. Through url we can only send get request by default.
IRL we use body to send data, 95% of the time. But first, we should see what is Middlewares. If we introduce a middleware then any request first go to middleware, which does some logic like authentication check and then the control reaches the other functions. Middleware in nodejs takes 3 argument- req,res and next, next is the next handler that we want to use if the request passes the logic of middleware. Have to write app.use(middleware1) to tell express to register the middleware so that all the requests are first sent to the middleware. Call next() in the middleware1 function which automatically calls the function for that route. Middleware can also send res using res.send('hi') if we don't want to call the next function. If we try to send res.send() and also call next() which also contains res.send() then it will give error. Middleware is a function which is called before any route handler is called for any request. Middleware also helps to define a logic that we want to use in every route handler
Body is something that express don't give us out of the box as like query params and headers. req.body is nothing as of req.query or req.headers. Express is a generic server, so you will bring xml,text,json,etc formats, they don''t want to provide support of all of them, that is why we have to use external libraries built by people called body-parser. npm install body-parser. app.use(bodyParser.json()). this bodyparser.json is a external middleware that we are using. bodyparser.json is a new middleware, which is just a funcition that extracts and parses the json in the body in the background, whose procedure we don't need to know. now we can use req.body().
